use crate::{
    asset_importer::ImportContext,
    components::GlobalTransform,
    rendering::{material::NO_MATERIAL, vertex::Vertex},
    resources::render_context,
};
use bevy_mikktspace::Geometry;
use itertools::izip;
use nalgebra::{vector, Point3, Vector2, Vector3, Vector4};
use render_context::RenderContext;

/// Geometry for a mesh
/// Automatically generated by `gltf_loader`
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Primitive {
    /// Offset into the index buffer
    pub index_buffer_offset: u32,
    /// Offset into vertex buffer
    pub vertex_buffer_offset: u32,
    /// Number of vertices
    pub indices_count: u32,
    /// Material used
    pub material_id: u32,
    /// Bounding sphere - used for culling
    pub bounding_sphere: Vector4<f32>,
}

impl Primitive {
    /// Create a new primitive using a list of vertices, indices and a material ID.
    pub fn new(
        vertices: &[Vertex],
        indices: &[u32],
        material_id: u32,
        render_context: &mut RenderContext,
    ) -> Self {
        let primitive = Primitive {
            indices_count: indices.len() as _,
            material_id,
            index_buffer_offset: render_context.resources.index_buffer.len as _,
            vertex_buffer_offset: render_context.resources.vertex_buffer.len as _,
            bounding_sphere: calculate_bounding_sphere(vertices),
        };

        unsafe {
            render_context.resources.index_buffer.append(indices);
            render_context.resources.vertex_buffer.append(vertices);
        }

        primitive
    }

    pub(crate) fn load(
        primitive_data: gltf::Primitive,
        import_context: &mut ImportContext,
        mesh_name: &str,
    ) -> Self {
        let mut indices = Vec::new();
        let mut positions = Vec::new();
        let mut tex_coords = Vec::new();
        let mut normals = Vec::new();
        let mut tangents = Vec::new();
        let mut joint_indices = Vec::new();
        let mut joint_weights = Vec::new();

        // Indicates whether the source geometry has tangent information
        let mut has_tangents = false;

        let reader = primitive_data.reader(|_| Some(&import_context.buffer));

        // Positions
        for v in reader
            .read_positions()
            .unwrap_or_else(|| panic!("Mesh {} has no positions!", mesh_name))
        {
            positions.push(vector![v[0], v[1], v[2]]);
        }

        // Indices
        if let Some(iter) = reader.read_indices() {
            for i in iter.into_u32() {
                indices.push(i);
            }
        }

        // Normals
        if let Some(iter) = reader.read_normals() {
            for v in iter {
                normals.push(vector![v[0], v[1], v[2]]);
            }
        } else {
            for _ in 0..positions.len() {
                normals.push(vector![0., 0., 0.]);
            }
        }

        // Tangents
        if let Some(iter) = reader.read_tangents() {
            for v in iter {
                tangents.push(vector![v[0], v[1], v[2], v[3]]);
            }
            has_tangents = true;
        } else {
            for _ in 0..positions.len() {
                tangents.push(Default::default());
            }
        }

        if let Some(iter) = reader.read_tex_coords(0) {
            for v in iter.into_f32() {
                tex_coords.push(vector![v[0], v[1]]);
            }
        } else {
            for _ in 0..positions.len() {
                tex_coords.push(vector![0., 0.]);
            }
        }

        if let Some(iter) = reader.read_joints(0) {
            for t in iter.into_u16() {
                joint_indices.push(vector![t[0] as f32, t[1] as f32, t[2] as f32, t[3] as f32]);
            }
        } else {
            for _ in 0..positions.len() {
                joint_indices.push(vector![0., 0., 0., 0.]);
            }
        }

        if let Some(iter) = reader.read_weights(0) {
            for t in iter.into_f32() {
                joint_weights.push(vector![t[0] as f32, t[1] as f32, t[2] as f32, t[3] as f32]);
            }
        } else {
            for _ in 0..positions.len() {
                joint_weights.push(vector![0., 0., 0., 0.]);
            }
        }

        if !has_tangents {
            let mut helper =
                MikktspaceHelper::new(&indices, &positions, &normals, &tex_coords, &mut tangents);
            let success = bevy_mikktspace::generate_tangents(&mut helper);
            assert!(success, "Error generating tangents!");
        }

        let vertices: Vec<Vertex> = izip!(
            positions,
            normals,
            tangents,
            tex_coords,
            joint_indices,
            joint_weights
        )
        .into_iter()
        .map(Vertex::from_zip)
        .collect();

        // All the materials in this glTF file will be imported into the material buffer, so all we need
        // to do is grab the index of this material and add it to the running offset. If we don't do this,
        // importing multiple glTF files will result in sadness, misery, and really ugly looking scenes.
        let material_id = if let Some(id) = primitive_data.material().index() {
            id as u32 + import_context.material_buffer_offset
        } else {
            NO_MATERIAL as u32
        };

        Primitive::new(
            &vertices,
            &indices,
            material_id,
            import_context.render_context,
        )
    }

    /// Get a bounding sphere for the primitive, applying a transform
    pub fn get_bounding_sphere(&self, global_transform: &GlobalTransform) -> Vector4<f32> {
        let center_in_local: Point3<_> = self.bounding_sphere.xyz().into();
        let center_in_global =
            Point3::<_>::from_homogeneous(global_transform.0 * center_in_local.to_homogeneous())
                .unwrap();

        // The linear part contains the rotation and scale, we are interested in the scale.
        let global_from_local_linear_part = global_transform.0.fixed_slice::<3, 3>(0, 0);

        // The scale of the sphere is taken as the largest scale in any dimension.
        // If the scale is uniform, the quality of the bounding sphere will be unchanged.
        // If the scale is non-uniform and axis aligned in local space, there could be a tighter bounding sphere.
        // If the scale is non-uniform and not axis aligned in local space (skew), the bounding sphere may be too tight.
        // If the case with skew becomes a problem in practice, there are several ways to solve it, eg:
        // * Using singular value decomposition can give a solution similar to the axis aligned case.
        // * Using a fudge factor can ensure correctness with a bounding sphere that usually is bigger than it needs to be.
        let scale = global_from_local_linear_part
            .column(0)
            .magnitude_squared()
            .max(global_from_local_linear_part.column(1).magnitude_squared())
            .max(global_from_local_linear_part.column(2).magnitude_squared())
            .sqrt();
        let radius_in_global = self.bounding_sphere.w * scale;

        [
            center_in_global.x,
            center_in_global.y,
            center_in_global.z,
            radius_in_global,
        ]
        .into()
    }
}

/// Get a bounding sphere for the primitive, used for occlusion culling
pub fn calculate_bounding_sphere(vertices: &[Vertex]) -> Vector4<f32> {
    let points = vertices.iter().map(|v| v.position).collect::<Vec<_>>();
    let num_points = points.len();
    if num_points == 0 {
        return Default::default();
    }

    let mut center = Vector3::zeros();
    for p in &points {
        center += p;
    }

    center /= num_points as f32;
    let mut radius = (points[0] - center).norm_squared();
    for p in points.iter().skip(1) {
        radius = radius.max((p - center).norm_squared());
    }

    radius = next_up(radius.sqrt());

    [center.x, center.y, center.z, radius].into()
}

const TINY_BITS: u32 = 0x1; // Smallest positive f32.
const CLEAR_SIGN_MASK: u32 = 0x7fff_ffff;

fn next_up(n: f32) -> f32 {
    let bits = n.to_bits();
    if n.is_nan() || bits == f32::INFINITY.to_bits() {
        return n;
    }

    let abs = bits & CLEAR_SIGN_MASK;
    let next_bits = if abs == 0 {
        TINY_BITS
    } else if bits == abs {
        bits + 1
    } else {
        bits - 1
    };
    f32::from_bits(next_bits)
}

// Broadly lifted from Bevy:
// https://github.com/bevyengine/bevy/blob/4847f7e3adc835053a8907dd578c342b4bd395e2/crates/bevy_render/src/mesh/mesh/mod.rs
struct MikktspaceHelper<'a> {
    indices: &'a Vec<u32>,
    positions: &'a Vec<Vector3<f32>>,
    normals: &'a Vec<Vector3<f32>>,
    uvs: &'a Vec<Vector2<f32>>,
    tangents: &'a mut Vec<Vector4<f32>>,
}

impl<'a> MikktspaceHelper<'a> {
    fn new(
        indices: &'a Vec<u32>,
        positions: &'a Vec<Vector3<f32>>,
        normals: &'a Vec<Vector3<f32>>,
        uvs: &'a Vec<Vector2<f32>>,
        tangents: &'a mut Vec<Vector4<f32>>,
    ) -> Self {
        Self {
            indices,
            positions,
            normals,
            uvs,
            tangents,
        }
    }

    fn index(&self, face: usize, vert: usize) -> usize {
        let index_index = face * 3 + vert;
        self.indices[index_index] as usize
    }
}

impl Geometry for MikktspaceHelper<'_> {
    fn num_faces(&self) -> usize {
        self.indices.len() / 3
    }

    fn num_vertices_of_face(&self, _: usize) -> usize {
        3
    }

    fn position(&self, face: usize, vert: usize) -> [f32; 3] {
        self.positions[self.index(face, vert)].into()
    }

    fn normal(&self, face: usize, vert: usize) -> [f32; 3] {
        self.normals[self.index(face, vert)].into()
    }

    fn tex_coord(&self, face: usize, vert: usize) -> [f32; 2] {
        self.uvs[self.index(face, vert)].into()
    }

    fn set_tangent_encoded(&mut self, mut tangent: [f32; 4], face: usize, vert: usize) {
        let index = self.index(face, vert);

        // !! IMPORTANT !! Flip the handedness of the generated tangent. See:
        // https://github.com/KhronosGroup/glTF-Sample-Models/issues/174#issuecomment-779532934
        tangent[3] *= -1.;
        self.tangents[index] = tangent.into();
    }
}
