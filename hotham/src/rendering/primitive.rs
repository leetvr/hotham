use crate::{
    asset_importer::ImportContext,
    contexts::render_context,
    rendering::{material::NO_MATERIAL, vertex::Vertex},
};
use glam::{Affine3A, Vec3, Vec4};
use itertools::izip;
use render_context::RenderContext;

/// Geometry for a mesh
/// Automatically generated by `gltf_loader`
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Primitive {
    /// Offset into the index buffer
    pub index_buffer_offset: u32,
    /// Offset into vertex buffer
    pub vertex_buffer_offset: u32,
    /// Number of vertices
    pub indices_count: u32,
    /// Material used
    pub material_id: u32,
    /// Bounding sphere - used for culling
    pub bounding_sphere: Vec4,
}

// fn f32_to_f16(f: f32) -> u16 {
//     let x = f as u32;
//     let sign: u32 = x >> 31;
//     let mut mantissa: u32;
//     let exp: u32;
//     let hf: u16;

//     mantissa = x & ((1 << 23) - 1);
//     exp = x & (0xFF << 23);
//     if exp >= 0x47800000 {
//         // check if the original number is a NaN
//         if (mantissa && (exp == (0xFF << 23))) {
//         // single precision NaN
//         mantissa = (1 << 23) - 1;
//         } else {
//         // half-float will be Inf
//         mantissa = 0;
//         }
//         hf = (((uint16_t)sign) << 15) | (uint16_t)((0x1F << 10)) |
//             (uint16_t)(mantissa >> 13);
//     }
//     // check if exponent is <= -15
//     else if (exp <= 0x38000000) {
//         hf = 0;  // too small to be represented
//     } else {
//         hf = (((uint16_t)sign) << 15) | (uint16_t)((exp - 0x38000000) >> 13) |
//             (uint16_t)(mantissa >> 13);
//     }

//     return hf;
// }

impl Primitive {
    /// Create a new primitive using a list of vertices, indices and a material ID.
    pub fn new(
        positions: &[Vec3],
        vertices: &[Vertex],
        indices: &[u32],
        material_id: u32,
        render_context: &mut RenderContext,
    ) -> Self {
        let primitive = Primitive {
            indices_count: indices.len() as _,
            material_id,
            index_buffer_offset: render_context.resources.index_buffer.data.len() as _,
            vertex_buffer_offset: render_context.resources.vertex_buffer.data.len() as _,
            bounding_sphere: calculate_bounding_sphere(positions),
        };

        // let positions = positions
        //     .iter()
        //     .map(|p| p.to_array().map(f32_to_f16))
        //     .collect::<Vec<_>>();

        unsafe {
            render_context.resources.index_buffer.append(indices);
            render_context.resources.position_buffer.append(positions);
            render_context.resources.vertex_buffer.append(vertices);
        }

        primitive
    }

    pub(crate) fn load(
        primitive_data: gltf::Primitive,
        import_context: &mut ImportContext,
        mesh_name: &str,
    ) -> Self {
        let mut indices = Vec::new();
        let mut positions = Vec::new();
        let mut tex_coords = Vec::new();
        let mut normals = Vec::new();
        let mut joint_indices = Vec::new();
        let mut joint_weights = Vec::new();

        let reader = primitive_data.reader(|_| Some(&import_context.buffer));

        // Positions
        for v in reader
            .read_positions()
            .unwrap_or_else(|| panic!("Mesh {} has no positions!", mesh_name))
        {
            positions.push([v[0], v[1], v[2]].into());
        }

        // Indices
        if let Some(iter) = reader.read_indices() {
            for i in iter.into_u32() {
                indices.push(i);
            }
        }

        // Normals
        if let Some(iter) = reader.read_normals() {
            for v in iter {
                normals.push([v[0], v[1], v[2]].into());
            }
        } else {
            for _ in 0..positions.len() {
                normals.push([0., 0., 0.].into());
            }
        }

        if let Some(iter) = reader.read_tex_coords(0) {
            for v in iter.into_f32() {
                tex_coords.push([v[0], v[1]].into());
            }
        } else {
            for _ in 0..positions.len() {
                tex_coords.push([0., 0.].into());
            }
        }

        if let Some(iter) = reader.read_joints(0) {
            for t in iter.into_u16() {
                joint_indices.push([t[0] as u8, t[1] as u8, t[2] as u8, t[3] as u8]);
            }
        } else {
            for _ in 0..positions.len() {
                joint_indices.push([0, 0, 0, 0]);
            }
        }

        if let Some(iter) = reader.read_weights(0) {
            for t in iter.into_f32() {
                joint_weights.push([t[0] as f32, t[1] as f32, t[2] as f32, t[3] as f32].into());
            }
        } else {
            for _ in 0..positions.len() {
                joint_weights.push([0., 0., 0., 0.].into());
            }
        }

        let vertices: Vec<Vertex> = izip!(normals, tex_coords, joint_indices, joint_weights)
            .into_iter()
            .map(Vertex::from_zip)
            .collect();

        // All the materials in this glTF file will be imported into the material buffer, so all we need
        // to do is grab the index of this material and add it to the running offset. If we don't do this,
        // importing multiple glTF files will result in sadness, misery, and really ugly looking scenes.
        let material_id = if let Some(id) = primitive_data.material().index() {
            id as u32 + import_context.material_buffer_offset
        } else {
            NO_MATERIAL as u32
        };

        Primitive::new(
            &positions,
            &vertices,
            &indices,
            material_id,
            import_context.render_context,
        )
    }

    /// Get a bounding sphere for the primitive, applying a transform
    pub fn get_bounding_sphere_in_gos(&self, gos_from_local: &Affine3A) -> Vec4 {
        let center_in_local = self.bounding_sphere.truncate();
        let center_in_gos = gos_from_local.transform_point3(center_in_local);

        // If this entity was scaled, we'll need to multiply the radius of its sphere by the *largest* element
        // of its scale.
        let (scale, _, _) = gos_from_local.to_scale_rotation_translation();
        let scale = scale.max_element();
        let radius_in_gos = self.bounding_sphere.w * scale;

        [
            center_in_gos.x,
            center_in_gos.y,
            center_in_gos.z,
            radius_in_gos,
        ]
        .into()
    }
}

/// Get a bounding sphere for the primitive, used for occlusion culling
///
/// This algorithm is loosely lifted from the official Vulkan examples - don't ask me how it works.
pub fn calculate_bounding_sphere(points: &[Vec3]) -> Vec4 {
    let num_points = points.len();
    if num_points == 0 {
        return Default::default();
    }

    let mut center = Vec3::ZERO;
    for p in points {
        center += *p;
    }

    center /= num_points as f32;
    let mut radius = (points[0] - center).length_squared();
    for p in points.iter().skip(1) {
        radius = radius.max((*p - center).length_squared());
    }

    radius = next_up(radius.sqrt());

    [center.x, center.y, center.z, radius].into()
}

const TINY_BITS: u32 = 0x1; // Smallest positive f32.
const CLEAR_SIGN_MASK: u32 = 0x7fff_ffff;

fn next_up(n: f32) -> f32 {
    let bits = n.to_bits();
    if n.is_nan() || bits == f32::INFINITY.to_bits() {
        return n;
    }

    let abs = bits & CLEAR_SIGN_MASK;
    let next_bits = if abs == 0 {
        TINY_BITS
    } else if bits == abs {
        bits + 1
    } else {
        bits - 1
    };
    f32::from_bits(next_bits)
}
